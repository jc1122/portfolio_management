# Portfolio Construction Script: `construct_portfolio.py`

## Overview

This script is the fifth step in the portfolio management toolkit's data pipeline. This is where financial theory is applied to the historical returns data to create a portfolio.

Its purpose is to take the matrix of asset returns and, based on a chosen investment strategy and a set of user-defined constraints, calculate the optimal **weight** (or allocation percentage) for each asset.

Like the other scripts, this file acts as a command-line **orchestrator** for the core logic encapsulated in the `PortfolioConstructor` class.

## Inputs (Prerequisites)

This script requires one primary input and one optional input from previous steps:

1. **Returns Matrix CSV (Required)**

   - **Generated by**: `scripts/calculate_returns.py`
   - **Specified via**: `--returns`
   - **Purpose**: This file provides the historical return data for all assets, which is the foundation for all quantitative strategies.

1. **Classifications CSV (Optional)**

   - **Generated by**: `scripts/classify_assets.py`
   - **Specified via**: `--classifications`
   - **Purpose**: This file is only needed if you intend to use constraints based on asset classes, such as `--max-equity` or `--min-bond`.

## Script Products

The script's output depends on its mode of operation:

1. **Portfolio Weights CSV (Primary Product)**

   - **Description**: When running with a single strategy, the script produces a CSV file with two columns: one for the asset tickers and one for their calculated `weight` in the portfolio. This file is the direct input for the `run_backtest.py` script.

1. **Strategy Comparison CSV**

   - **Description**: When running with the `--compare` flag, the script produces a CSV file where the rows are the asset tickers and each column represents a different investment strategy. The values in the table are the weights assigned to each asset by each strategy. This is useful for analysis and comparison.

## Features in Detail

### Portfolio Construction Strategies

The core feature of the script is its ability to build a portfolio using different industry-standard strategies, controlled by the `--strategy` flag.

- `equal_weight`: The simplest baseline. It assigns an equal weight to every asset (1/N).
- `mean_variance_max_sharpe`: A classic Modern Portfolio Theory strategy that finds the portfolio with the mathematically optimal risk-adjusted return (highest Sharpe Ratio).
- `mean_variance_min_volatility`: An MPT strategy that finds the portfolio with the lowest possible risk (volatility), regardless of return.
- `risk_parity`: An advanced strategy that allocates capital so that each asset contributes equally to the overall portfolio risk.

### Large-Universe Hardening

Running the optimiser across hundreds of tickers can surface numerical edge cases. The strategies now include guard rails so 1,000-name universes stay tractable without hand-tuning:

- `risk_parity` automatically falls back to an inverse-volatility solution when more than 300 assets are present, while still enforcing all portfolio constraints, and it stabilises the covariance matrix with a light diagonal “jitter” whenever the inputs are nearly singular.
- `mean_variance_*` sanitises return inputs, applies shrinkage to the covariance matrix, and will switch to a closed-form tangency approximation when the universe is extremely large or PyPortfolioOpt struggles to converge. The resulting weights are normalised and validated against the same constraint set as the main optimiser.

These safeguards match the configuration used for the `long_history_1000` runs and remove the need for ad-hoc ticker pruning when scaling up experiments.

### Portfolio Constraints

Constraints are rules that the final portfolio must obey. They allow you to enforce your own views or risk limits on top of the chosen strategy.

- `--max-weight` / `--min-weight`: Sets the maximum and minimum allowable weight for any single asset.
- `--max-equity`: Sets the maximum total allocation to all assets classified as "equity".
- `--min-bond`: Sets the minimum total allocation to all assets classified as "fixed_income" or "cash".

### Strategy Comparison Mode

Instead of building a single portfolio, you can use the `--compare` flag. This tells the script to run **all** available strategies and generate a single table comparing the weights produced by each, making it easy to see how different theories allocate capital to the same set of assets.

## Usage Examples

```bash
# Construct a simple equal-weight portfolio
python scripts/construct_portfolio.py \
  --returns data/processed/returns.csv \
  --strategy equal_weight \
  --output outputs/portfolio_equal_weight.csv
```

```bash
# Construct a Mean-Variance portfolio with exposure constraints
python scripts/construct_portfolio.py \
  --returns data/processed/returns.csv \
  --classifications data/processed/classified_assets.csv \
  --strategy mean_variance_max_sharpe \
  --max-equity 0.80 \
  --min-bond 0.15 \
  --output outputs/portfolio_mv.csv
```

```bash
# Compare all available strategies
python scripts/construct_portfolio.py \
  --returns data/processed/returns.csv \
  --compare \
  --output outputs/portfolio_comparison.csv
```

## Command-Line Arguments

- `--returns`: **(Required)** Path to the CSV file containing asset returns.
- `--output`: **(Required)** Path to write the resulting portfolio weights CSV.
- `--classifications`: Optional path to the classified assets CSV, required for exposure constraints.
- `--strategy`: The name of the strategy to use (e.g., `equal_weight`). Default: `equal_weight`.
- `--compare`: If specified, runs all strategies and compares them.
- `--max-weight`: Maximum weight for any single asset. Default: `0.25`.
- `--min-weight`: Minimum weight for any single asset. Default: `0.0`.
- `--max-equity`: Maximum total exposure to equity. Default: `0.90`.
- `--min-bond`: Minimum total exposure to bonds/cash. Default: `0.10`.
- `--verbose`: Enable detailed logging output.

## Cardinality Constraints

Cardinality constraints limit the number of positions in the portfolio. The toolkit supports two approaches:

1. **Preselection (Current)**: Use factor-based preselection to filter assets before optimization
   - See `docs/preselection.md` for details
   - Fast, deterministic, factor-driven
   - No special solver requirements

2. **Optimizer-Integrated (Future)**: Enforce cardinality within the optimization
   - See `docs/cardinality_constraints.md` for design details
   - Methods: MIQP, heuristics, relaxation
   - Currently design stubs only

The preselection approach is production-ready and recommended for most use cases. The optimizer-integrated approach provides extension points for future development when commercial solvers or heuristic algorithms are needed.

For more information:
- Current implementation: `docs/preselection.md`
- Future design: `docs/cardinality_constraints.md`
